### **Описание задачи**  
Тут уже немного сложнее, но цель всё ещё проста — ввести верный флаг. У нас есть бинарник, который делает какую-то магию с вводом, и надо понять, как из этой магии вытащить победу. Программа жмёт руку всем, кто знает основы реверс-инжиниринга и готов покопаться в шифрах.

## **Как подступились к проблеме**

### **1. Первое, что бросилось в глаза — функция `sub_1229`**  
Код программы быстро приводит к функции `sub_1229`, которая явно издевается над строкой. Что она делает:  
- Прогоняет каждый символ через пару операций: `XOR`, прибавления, вычитания... да так, что в итоге всё превращается в шифрованный ком :yum:.  

Псевдокод на C выглядел вот так:  
```
for (i = 0; i < a2; ++i) {
    *((BYTE *)(i + a1)) ^= 0x41;
    *((BYTE *)(i + a1)) += 52;
    *((BYTE *)(i + a1)) ^= 0x22;
    *((BYTE *)(i + a1)) -= 30;
}
```

Ну и что с этим делать? Разумеется, писать скрипт, который всё это раскрутит обратно.

---

### **2. Ключ к задаче — зашифрованная строка `s1`**  
В дизасме функции main заметно как обращаемся к зашифрованной строке `s1`. Это та самая зацепка для правильного ответа, которую программа сравнивает с нашим вводом:  
```
s1 = {
  0xF6, 0x42, 0xFD, 0xFC, 0xF7, 0x50, 0x2E, 0xF6,
  0x25, 0x58, 0x26, 0x26, 0x60, 0x56, 0x46, 0x52,
  0x67, 0x52, 0x24, 0x69, 0x27, 0xFC, 0x52, 0x5D,
  0x68, 0x5B, 0x5B, 0x34
};
```

Чтобы понять, что в этой строке скрыто, инвертируем все операции из `sub_1229`.  

### **3. Пишем скрипт для раскрутки**  
Теперь дело техники. Разорачиваем шифрование, в обратном порядке:  
1. Увеличиваем байт на `30`.  
2. `XOR` с `0x22`.  
3. Вычитаем `52`.  
4. `XOR`, но теперь с `0x41`.  

Вот как выглядит скрипт на Python:  
```
def reverse_sub_1229(data):
    result = []
    for byte in data:
        byte += 30         # Инвертируем вычитание 30
        byte ^= 0x22       # Инвертируем XOR с 0x22
        byte -= 52         # Инвертируем прибавление 52
        byte ^= 0x41       # Инвертируем XOR с 0x41
        result.append(byte & 0xFF)  # Учитываем переполнение
    return bytes(result)

s1_data = [
    0xF6, 0x42, 0xFD, 0xFC, 0xF7, 0x50, 0x2E, 0xF6,
    0x25, 0x58, 0x26, 0x26, 0x60, 0x56, 0x46, 0x52,
    0x67, 0x52, 0x24, 0x69, 0x27, 0xFC, 0x52, 0x5D,
    0x68, 0x5B, 0x5B, 0x34
]

original_input = reverse_sub_1229(s1_data)
print("Оригинальный ввод:", original_input.decode('utf-8'))
```

### **4. Концовка**  
Запускаем скрипт и получаем оригинальный ввод. Программа съедает его и сообщает, тот самый флаг который требует от нас исходный биарник.
